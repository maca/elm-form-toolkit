module FormToolkit.Input exposing
    ( Input, Msg, update, toHtml, toView
    , text, textarea, email, password
    , int, float
    , date, month
    , select, radio, checkbox
    , group, repeatable
    , Attribute
    , name, identifier, value, required, label, placeholder, hint
    , options, min, max
    , noattr
    , inline, copies, repeatableMin, repeatableMax
    , errors
    , map, mapValues
    )

{-| Provides types and functions to create and manage form inputs, including
various input types, attributes, and updating and rendering.


# Input

@docs Input, Msg, update, toHtml, toView


# Input types

@docs text, textarea, email, password
@docs int, float
@docs date, month
@docs select, radio, checkbox
@docs group, repeatable


# Attributes

@docs Attribute
@docs name, identifier, value, required, label, placeholder, hint
@docs options, min, max
@docs noattr


### Group

@docs inline, copies, repeatableMin, repeatableMax


# Errors

@docs errors


# Mapping and composition

@docs map, mapValues

-}

import FormToolkit.Decode exposing (Decoder, Error(..))
import FormToolkit.Value as Value
import FormToolkit.View as View
import Html exposing (Html)
import Internal.Input as Internal exposing (Input(..), Msg(..))
import Internal.Value
import RoseTree.Tree as Tree


type alias Tree id val =
    Internal.Tree id val (Error id val)


{-| Represents a form input element, which can be a field or a group of fields.

Can be individual input fields (like text, email, password) or composite inputs
like groups and repeatable groups.

The first type parameter `id` corresponds to an optional identifier, used for
referencing a specific [field](FormToolkit.Decode#field) while decoding or
updating attributes, the type parameter `val` refers to a [value of an
arbitrary type](FormToolkit.Value#custom) which can be assigned to a certain
value of a [select](#select).

Not always do you care about decoding the form or having selects with custom type
values in which case you can annotate the type of your `Input` as
`Input id val`, `Input Never Never`, `Input () ()`, or however you prefer.

-}
type alias Input id val =
    Internal.Input id val (Error id val)


{-| A message generated by a user input.
-}
type alias Msg id =
    Internal.Msg id


{-| Update a form passing a decoder to validate and produce a result,
and a [Msg](#Msg) to reflect user interactions.
-}
update :
    Decoder id val a
    -> Msg id
    -> Input id val
    -> ( Input id val, Result (List (Error id val)) a )
update decoder msg input =
    FormToolkit.Decode.validateAndDecode decoder <|
        case msg of
            InputChanged path str ->
                updateAt path (updateInput str) input

            InputChecked path bool ->
                updateAt path (updateInputWithBool bool) input

            InputFocused path ->
                updateAt path (Tree.updateValue Internal.focus) input

            InputBlured path ->
                updateAt path (Tree.updateValue Internal.blur) input

            InputsAdded path ->
                case
                    Tree.getValueAt path (toTree input)
                        |> Maybe.map .inputType
                of
                    Just (Internal.Repeatable template) ->
                        updateAt path (Tree.push template) input

                    _ ->
                        input

            InputsRemoved path ->
                Input (Tree.removeAt path (toTree input))


{-|

    view : Html (Never -> a)
    view =
        Input.group []
            [ Input.text [ Input.label "First Name" ]
            , Input.text [ Input.label "Last Name" ]
            ]
            |> Input.toHtml (always never)

-}
toHtml : (Msg id -> msg) -> Input id val -> Html msg
toHtml tagger input =
    View.fromInput tagger input |> View.toHtml


{-| Convert the input to [View](FormToolkit.View#View) as a step before
rendering it to HTML in order to have it customized.

    view : View id (Input.Msg id)
    view =
        Input.group []
            [ Input.text [ Input.label "First Name" ]
            , Input.text [ Input.label "Last Name" ]
            ]
            |> Input.toView (always never)

-}
toView : (Msg id -> msg) -> Input id val -> View.View id val msg
toView =
    View.fromInput


updateInput : String -> Tree id val -> Tree id val
updateInput string =
    Tree.updateValue (Internal.updateValueWithString string)


updateInputWithBool : Bool -> Tree id val -> Tree id val
updateInputWithBool bool =
    Tree.updateValue (Internal.updateValue (Internal.Value.fromBool bool))


updateAt : List Int -> (Tree id val -> Tree id val) -> Input id val -> Input id val
updateAt path func input =
    Input (Tree.updateAt path func (toTree input))


{-| Creates a text input field.

    usernameInput : Input id val
    usernameInput =
        text [ label "Username", placeholder "Enter your username" ]

-}
text : List (Attribute id val) -> Input id val
text =
    init Internal.Text


{-| Creates a textarea input field.

    commentsInput : Input id val
    commentsInput =
        textarea [ label "Comments", placeholder "Enter your comments here" ]

-}
textarea : List (Attribute id val) -> Input id val
textarea =
    init Internal.TextArea


{-| Creates an email input field.

    emailInput : Input id val
    emailInput =
        email [ label "Email", required True ]

-}
email : List (Attribute id val) -> Input id val
email =
    init Internal.Email


{-| Creates a password input field.

    passwordInput : Input id val
    passwordInput =
        password [ label "Password", required True ]

-}
password : List (Attribute id val) -> Input id val
password =
    init Internal.Password


{-| Creates an integer input field.

    ageInput : Input id val
    ageInput =
        int [ label "Age", min (Value.int 0), max (Value.int 120) ]

-}
int : List (Attribute id val) -> Input id val
int =
    init Internal.Integer


{-| Creates a floating-point number input field.

    priceInput : Input id val
    priceInput =
        float [ label "Price", min (Value.float 0.0) ]

-}
float : List (Attribute id val) -> Input id val
float =
    init Internal.Float


{-| Creates a date input field.

    birthdateInput : Input id val
    birthdateInput =
        date [ label "Birthdate", required True ]

-}
date : List (Attribute id val) -> Input id val
date =
    init Internal.Date


{-| Creates a month input field.

    monthInput : Input id val
    monthInput =
        month [ label "Expiry Month" ]

-}
month : List (Attribute id val) -> Input id val
month =
    init Internal.Month


{-| Creates a select input field (dropdown).

    type Lang
        = ES
        | EN
        | DE

    langSelect : Input id Lang
    langSelect =
        select
            [ label "Language"
            , options
                [ ( "Español", Value.custom ES )
                , ( "English", Value.custom EN )
                , ( "Deutsch", Value.custom DE )
                ]
            ]

-}
select : List (Attribute id val) -> Input id val
select =
    init Internal.Select


{-| Creates a radio button input field.

    lightOnInput : Input id val
    lightOnInput =
        radio
            [ label "Light is"
            , options
                [ ( "On", Value.bool True )
                , ( "Off", Value.bool False )
                ]
            ]

-}
radio : List (Attribute id val) -> Input id val
radio =
    init Internal.Radio


{-| Creates a checkbox input field.

    consentInput : Input id val
    consentInput =
        checkbox [ label "Subscribe to newsletter" ]

-}
checkbox : List (Attribute id val) -> Input id val
checkbox =
    init Internal.Checkbox


{-| Creates a group of inputs.

Groups multiple inputs together.

    nameInputs : Input id val
    nameInputs =
        group []
            [ text [ name "firstName", label "First Name" ]
            , text [ name "lastName", label "Last Name" ]
            ]

-}
group : List (Attribute id val) -> List (Input id val) -> Input id val
group attributes inputs =
    List.map toTree inputs
        |> Tree.branch
            (Internal.init Internal.Group (unwrapAttrs attributes))
        |> Input


{-| Creates a repeatable group of inputs.

Allows inputs to be repeated multiple times.

    emailsInputs : Input id val
    emailsInputs =
        repeatable
            [ name "emails"
            , repeatableMin 1
            , repeatableMax 5
            ]
            (text [ placeholder "Enter email address" ])
            []

-}
repeatable : List (Attribute id val) -> Input id val -> List (Input id val) -> Input id val
repeatable attributes template inputs =
    let
        params =
            Internal.init (Internal.Repeatable (toTree template))
                (unwrapAttrs attributes)

        children =
            List.map toTree inputs
                ++ List.repeat (params.repeatableMin - List.length inputs)
                    (toTree template)
    in
    Input (Tree.branch params children)


init : Internal.InputType id val (Error id val) -> List (Attribute id val) -> Input id val
init inputType attributes =
    Input (Tree.leaf (Internal.init inputType (unwrapAttrs attributes)))


unwrapAttrs :
    List (Attribute id val)
    -> List (Internal.Attrs id val (Error id val) -> Internal.Attrs id val (Error id val))
unwrapAttrs =
    List.map (\(Attribute f) -> f)


toTree : Input id val -> Tree id val
toTree (Input tree) =
    tree


{-| Represents an attribute that can be applied to an input.
-}
type Attribute id val
    = Attribute (Internal.Attrs id val (Error id val) -> Internal.Attrs id val (Error id val))


{-| Sets the name of an input.

        text
            [ label "First name"
            , name "first-name"
            , value (Value.string "Chavela")
            ]
            |> FormToolkit.Decode.decode FormToolkit.Decode.json
            |> Result.map (Json.Encode.encode 0)
            -- Ok "{\"first-name\":\"Chavela\"}"

-}
name : String -> Attribute id val
name str =
    Attribute (\input -> { input | name = Just str })


{-| Sets the identifier to be reference when decoding a specific field.


    type Fields
        = FirstName
        | LastName

    form : Input Fields value
    form =
        group []
            [ text
                [ label "First name"
                , identifier FirstName
                , value (Value.string "Juan")
                ]
            , text
                [ label "Last name"
                , identifier LastName
                , value (Value.string "Perez")
                ]
            ]

    decoded =
        form
            |> FormToolkit.Decode.decode
                (FormToolkit.Decode.field FirstName FormToolkit.Decode.string)

    -- Ok "Juan"

-}
identifier : id -> Attribute id val
identifier id =
    Attribute (\input -> { input | identifier = Just id })


{-| Sets the value of an input. See [Value](FormToolkit.Value#Value)

    yesSelect : Input id ( Bool, Bool )
    yesSelect =
        select
            [ label "Language"
            , options
                [ ( "Yes-yes", Value.custom ( True, True ) )
                , ( "Yes-no", Value.custom ( True, False ) )
                , ( "No-yes", Value.custom ( False, True ) )
                , ( "No-no", Value.custom ( False, False ) )
                ]
            ]

-}
value : Value.Value val -> Attribute id val
value (Value.Value inputValue) =
    Attribute (\input -> { input | value = inputValue })


{-| Marks an input as required, parsing and validation will fail and the missing
field error will be displayed.
-}
required : Bool -> Attribute id val
required bool =
    Attribute (\input -> { input | isRequired = bool })


{-| Sets the label of an input.
-}
label : String -> Attribute id val
label str =
    Attribute (\input -> { input | label = Just str })


{-| Sets the placeholder text of an input.
-}
placeholder : String -> Attribute id val
placeholder str =
    Attribute (\input -> { input | placeholder = Just str })


{-| Sets a hint or help text for an input.
-}
hint : String -> Attribute id val
hint str =
    Attribute (\input -> { input | hint = Just str })


{-| Sets the options for a select, radio, or checkbox input.
-}
options : List ( String, Value.Value val ) -> Attribute id val
options values =
    Attribute
        (\input ->
            { input
                | options =
                    List.map (Tuple.mapSecond (\(Value.Value val) -> val))
                        values
            }
        )


{-| Sets the minimum value for an input when the value is scalar (int, float,
date, ...).
-}
min : Value.Value val -> Attribute id val
min (Value.Value val) =
    Attribute (\input -> { input | min = val })


{-| Sets the maximum value for an input when the value is scalar (int, float,
date, ...).
-}
max : Value.Value val -> Attribute id val
max (Value.Value val) =
    Attribute (\input -> { input | max = val })


{-| An attribute that does nothing.
-}
noattr : Attribute id val
noattr =
    Attribute identity


{-| Sets whether the inputs in a group are displayed inline.
-}
inline : Bool -> Attribute id val
inline bool =
    Attribute (\input -> { input | inline = bool })


{-| Sets the text for the add and remove buttons in a repeatable input.
-}
copies : { addButton : String, removeButton : String } -> Attribute id val
copies { addButton, removeButton } =
    Attribute
        (\input ->
            { input
                | addInputsText = addButton
                , removeInputsText = removeButton
            }
        )


{-| Sets the minimum number of copies for a repeatable input.
-}
repeatableMin : Int -> Attribute id val
repeatableMin integer =
    Attribute (\input -> { input | repeatableMin = integer })


{-| Sets the maximum number of copies for a repeatable input.
-}
repeatableMax : Int -> Attribute id val
repeatableMax integer =
    Attribute (\input -> { input | repeatableMax = Just integer })


{-| Collects all errors from an input and its children.
-}
errors : Input id val -> List (Error id val)
errors (Input tree) =
    case Tree.children tree of
        [] ->
            Tree.value tree |> .errors

        children ->
            (Tree.value tree |> .errors)
                :: List.map (errors << Input) children
                |> List.concat


{-| Transforms identifiers or errors in an input, useful to combine inputs with
identifier of different type.

    type PersonFields
        = PersonName
        | PersonAge

    type TeamFields
        = TeamName
        | TeamMembers
        | MemberFields PersonFields

    personsFields : Input PersonFields
    personsFields =
        group []
            [ text
                [ label "Member Name"
                , identifier PersonName
                ]
            , int
                [ label "Member Age"
                , identifier PersonAge
                ]
            ]

    teamFields : Input TeamFields
    teamFields =
        group []
            [ text
                [ label "Team Name"
                , identifier TeamName
                ]
            , repeatable
                [ identifier TeamMembers ]
                -- ↓
                (map MemberFields personFields)
                -- ↑
                []
            ]

-}
map : (a -> b) -> Input a val -> Input b val
map func (Input tree) =
    Input (Tree.mapValues (Internal.map func identity (mapError func identity)) tree)


mapError : (a -> b) -> (Value.Value val1 -> Value.Value val2) -> Error a val1 -> Error b val2
mapError transformId transformVal error =
    case error of
        ValueTooLarge id params ->
            ValueTooLarge (Maybe.map transformId id)
                { value = transformVal params.value
                , max = transformVal params.max
                }

        ValueTooSmall id params ->
            ValueTooSmall (Maybe.map transformId id)
                { value = transformVal params.value
                , min = transformVal params.min
                }

        ValueNotInRange id params ->
            ValueNotInRange (Maybe.map transformId id)
                { value = transformVal params.value
                , min = transformVal params.min
                , max = transformVal params.max
                }

        IsBlank id ->
            IsBlank (Maybe.map transformId id)

        ParseError id ->
            ParseError (Maybe.map transformId id)

        ListError id params ->
            ListError (Maybe.map transformId id)
                { index = params.index
                , error = mapError transformId transformVal params.error
                }

        RepeatableHasNoName id ->
            RepeatableHasNoName (Maybe.map transformId id)

        InputNotFound id ->
            InputNotFound (transformId id)

        CustomError err ->
            CustomError err


{-| Map all of the values of an input, similary to [map](#map) that allows
combining inputs of different identifier type `mapValues` allows composing
inputs of different value type.

    select
        [ label "Language"
        , value (Value.custom ( True, False ))
        , options
            [ ( "Yes-yes", Value.custom ( True, True ) )
            , ( "Yes-no", Value.custom ( True, False ) )
            , ( "No-yes", Value.custom ( False, True ) )
            , ( "No-no", Value.custom ( False, False ) )
            ]
        ]
        |> mapValues (Value.mapCustom (Tuple.mapFirst not))
        == select
            [ label "Language"
            , value (Value.custom ( False, False ))
            , options
                [ ( "Yes-yes", Value.custom ( False, True ) )
                , ( "Yes-no", Value.custom ( False, False ) )
                , ( "No-yes", Value.custom ( True, True ) )
                , ( "No-no", Value.custom ( True, False ) )
                ]
            ]

-}
mapValues : (Value.Value val1 -> Value.Value val2) -> Input id val1 -> Input id val2
mapValues func (Input tree) =
    Input
        (Tree.mapValues
            (Internal.map identity
                (\val ->
                    case func (Value.Value val) of
                        Value.Value val_ ->
                            val_
                )
                (mapError identity func)
            )
            tree
        )
